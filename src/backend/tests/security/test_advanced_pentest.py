# backend/tests/test_advanced_pentest.py
import pytest
import json
import time
import hashlib
import hmac
import base64
import threading
from unittest.mock import patch, Mock
from cryptography.fernet import Fernet, InvalidToken

from backend.app.storage import (
    store_encrypted_secret,
    retrieve_and_delete_secret,
    check_secret_exists
)
from backend.app.encryption import encrypt_secret, decrypt_secret
from backend.app.models import Secret
from backend.app import db


class TestAdvancedCryptographicAttacks:
    """Test advanced cryptographic attack vectors."""
    
    def test_padding_oracle_attack_simulation(self, client, app_context):
        """Test resistance to padding oracle attacks."""
        # Store a secret first
        secret_data = {"secret": "padding_oracle_test"}
        response = client.post('/api/share',
                              data=json.dumps(secret_data),
                              content_type='application/json')
        
        assert response.status_code == 201
        data = json.loads(response.data)
        link_id = data['link_id']
        
        # Get the encrypted data from database directly
        secret = Secret.query.filter_by(link_id=link_id).first()
        if secret is None:
            pytest.skip("Secret not found in database")
            
        original_encrypted = secret.encrypted_secret
        
        # Try to manipulate encrypted data to probe for padding oracle
        tampered_versions = []
        for i in range(5):  # Test a few byte modifications
            tampered = bytearray(original_encrypted)
            if len(tampered) > i:
                tampered[i] = tampered[i] ^ 0xFF  # Flip all bits in byte
                tampered_versions.append(bytes(tampered))
        
        # Try to decrypt tampered versions - should all fail gracefully
        for tampered in tampered_versions:
            result = decrypt_secret(tampered)
            assert result is None, "Tampered encrypted data should not decrypt successfully"
        
        # Cleanup the original secret
        retrieve_and_delete_secret(link_id)
    
    def test_chosen_plaintext_attack_resistance(self, app_context):
        """Test resistance to chosen plaintext attacks."""
        # Test that encrypting known plaintexts doesn't reveal patterns
        known_plaintexts = [
            "A" * 16,  # All A's
            "B" * 16,  # All B's  
            "AAAAAAAAAAAAAAAB",  # Mostly A's with one B
            "password123",
            "admin",
            "test",
            "",  # Empty (should fail)
        ]
        
        encrypted_results = []
        for plaintext in known_plaintexts:
            try:
                if plaintext:  # Skip empty string
                    encrypted = encrypt_secret(plaintext)
                    encrypted_results.append((plaintext, encrypted))
            except (ValueError, TypeError):
                # Expected for empty string
                pass
        
        # Verify that similar plaintexts produce very different ciphertexts
        for i, (plain1, cipher1) in enumerate(encrypted_results):
            for j, (plain2, cipher2) in enumerate(encrypted_results[i+1:], i+1):
                # Even similar plaintexts should produce very different ciphertexts
                assert cipher1 != cipher2, f"Different plaintexts should produce different ciphertexts: '{plain1}' vs '{plain2}'"
                
                # Calculate byte differences
                min_len = min(len(cipher1), len(cipher2))
                differences = sum(1 for k in range(min_len) if cipher1[k] != cipher2[k])
                diff_percentage = differences / min_len * 100
                
                # Should have high percentage of different bytes (>40%)
                assert diff_percentage > 40, f"Ciphertexts should differ significantly: {diff_percentage}% for '{plain1}' vs '{plain2}'"
    
    def test_key_extraction_attempts(self, client):
        """Test attempts to extract encryption keys through various vectors."""
        key_extraction_attempts = [
            {"secret": "MASTER_ENCRYPTION_KEY"},
            {"secret": "key"},
            {"secret": "fernet_key"},
            {"secret": "encryption_key"},
            {"secret": "crypto_key"},
            {"secret": "secret_key"},
        ]
        
        for attempt in key_extraction_attempts:
            response = client.post('/api/share',
                                  data=json.dumps(attempt),
                                  content_type='application/json')
            
            if response.status_code == 201:
                data = json.loads(response.data)
                link_id = data['link_id']
                
                # Retrieve the "secret"
                retrieve_response = client.get(f'/api/share/secret/{link_id}')
                assert retrieve_response.status_code == 200
                
                retrieved_data = json.loads(retrieve_response.data)
                retrieved_secret = retrieved_data['secret']
                
                # Should return the literal string, not actual key
                assert retrieved_secret == attempt['secret']
                # Should not be a valid Fernet key
                if len(retrieved_secret.encode()) >= 32:
                    with pytest.raises(Exception):
                        Fernet(retrieved_secret.encode())
    
    def test_cryptographic_timing_attacks(self, app_context):
        """Test resistance to cryptographic timing attacks."""
        # Test encryption timing consistency
        plaintexts = [
            "a",  # 1 byte
            "a" * 10,  # 10 bytes
            "a" * 100,  # 100 bytes
            "a" * 1000,  # 1000 bytes
        ]
        
        encryption_times = []
        
        for plaintext in plaintexts:
            times = []
            for _ in range(10):  # Multiple measurements
                start = time.time()
                encrypted = encrypt_secret(plaintext)
                end = time.time()
                times.append(end - start)
                
                # Verify roundtrip
                decrypted = decrypt_secret(encrypted)
                assert decrypted == plaintext
            
            avg_time = sum(times) / len(times)
            encryption_times.append(avg_time)
        
        # Timing should not vary dramatically with input size for small inputs
        # (Fernet has built-in padding that normalizes this)
        max_time = max(encryption_times)
        min_time = min(encryption_times)
        
        # Variance should be reasonable (not more than 10x difference)
        assert max_time / min_time < 10, f"Encryption timing variance too high: {max_time/min_time}x"


class TestAdvancedBusinessLogicAttacks:
    """Test advanced business logic attack vectors."""
    
    def test_session_fixation_attempts(self, client):
        """Test session fixation attack attempts."""
        # Since this app doesn't use sessions, test that no session info leaks
        response1 = client.get('/health')
        response2 = client.get('/health')
        
        # No session cookies should be set
        assert 'Set-Cookie' not in response1.headers
        assert 'Set-Cookie' not in response2.headers
        
        # Test with various session-related headers
        session_headers = {
            'Cookie': 'PHPSESSID=malicious_session_id',
            'X-Requested-With': 'XMLHttpRequest',
            'X-Forwarded-For': '127.0.0.1',
            'X-Real-IP': '127.0.0.1'
        }
        
        response = client.get('/health', headers=session_headers)
        assert response.status_code == 200
        # Should not echo back any session info
        data = json.loads(response.data)
        assert 'PHPSESSID' not in str(data)
    
    def test_privilege_escalation_attempts(self, client):
        """Test privilege escalation attack attempts."""
        # Test admin-like requests
        admin_attempts = [
            {"secret": "admin", "role": "admin"},
            {"secret": "test", "admin": True},
            {"secret": "test", "privilege": "admin"},
            {"secret": "test", "access_level": "admin"},
            {"secret": "test", "is_admin": True},
        ]
        
        for attempt in admin_attempts:
            response = client.post('/api/share',
                                  data=json.dumps(attempt),
                                  content_type='application/json')
            
            # Should ignore extra fields and process normally
            assert response.status_code == 201
            
            data = json.loads(response.data)
            # Should not contain privilege info in response
            assert 'role' not in data
            assert 'admin' not in data
            assert 'privilege' not in data
    
    def test_secret_enumeration_attacks(self, client, app_context):
        """Test secret enumeration attack attempts."""
        # Store some secrets first
        stored_links = []
        for i in range(5):
            secret_data = {"secret": f"enumeration_test_{i}"}
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json')
            
            data = json.loads(response.data)
            stored_links.append(data['link_id'])
        
        # Try to enumerate with sequential/predictable IDs
        enumeration_attempts = [
            "00000000-0000-0000-0000-000000000001",
            "11111111-1111-1111-1111-111111111111",
            "aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa",
            "12345678-1234-1234-1234-123456789012",
        ]
        
        for attempt_id in enumeration_attempts:
            response = client.get(f'/api/share/secret/{attempt_id}')
            # Should return 404 for non-existent IDs
            assert response.status_code == 404
            
            # HEAD request should also return 404
            head_response = client.head(f'/api/share/secret/{attempt_id}')
            assert head_response.status_code == 404
        
        # Cleanup - retrieve stored secrets
        for link_id in stored_links:
            client.get(f'/api/share/secret/{link_id}')
    
    def test_secret_collision_attacks(self, app_context):
        """Test secret collision attack attempts."""
        # Try to force collisions by storing many secrets rapidly
        secrets = []
        link_ids = []
        
        for i in range(50):
            secret = f"collision_test_{i}"
            encrypted = encrypt_secret(secret)
            link_id = store_encrypted_secret(encrypted)
            
            # Verify no collision occurred
            assert link_id not in link_ids, f"Link ID collision detected: {link_id}"
            
            secrets.append(secret)
            link_ids.append(link_id)
        
        # All link IDs should be unique
        assert len(set(link_ids)) == len(link_ids), "All link IDs should be unique"
        
        # Verify all secrets can be retrieved correctly
        for secret, link_id in zip(secrets, link_ids):
            retrieved = retrieve_and_delete_secret(link_id)
            assert retrieved is not None, f"Secret should be retrievable: {link_id}"
            
            decrypted = decrypt_secret(retrieved)
            assert decrypted == secret, f"Decrypted secret should match original: {secret}"


class TestAdvancedInjectionAttacks:
    """Test advanced injection attack vectors."""
    
    def test_nosql_injection_attempts(self, client):
        """Test NoSQL injection attempts (even though we use SQL)."""
        nosql_payloads = [
            {"secret": {"$gt": ""}},
            {"secret": {"$ne": None}},
            {"secret": {"$where": "sleep(5000)"}},
            {"secret": {"$regex": ".*"}},
            {"secret": {"$or": [{"password": "admin"}, {"password": ""}]}},
        ]
        
        for payload in nosql_payloads:
            # These should be rejected as non-string secrets
            response = client.post('/api/share',
                                  data=json.dumps(payload),
                                  content_type='application/json')
            
            assert response.status_code == 400
            data = json.loads(response.data)
            assert "string" in data['error'].lower()
    
    def test_ldap_injection_attempts(self, client):
        """Test LDAP injection attempts in secret content."""
        ldap_payloads = [
            ")(cn=*))",
            "*(cn=*))(|(cn=*",
            "*)(|(password=*))",
            "admin)(|(password=*))",
            "*)(&(password=*))",
        ]
        
        for payload in ldap_payloads:
            secret_data = {"secret": payload}
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json')
            
            # Should store as regular string
            assert response.status_code == 201
            
            data = json.loads(response.data)
            link_id = data['link_id']
            
            # Should retrieve exactly as stored
            retrieve_response = client.get(f'/api/share/secret/{link_id}')
            assert retrieve_response.status_code == 200
            
            retrieved_data = json.loads(retrieve_response.data)
            assert retrieved_data['secret'] == payload
    
    def test_xpath_injection_attempts(self, client):
        """Test XPath injection attempts in secret content."""
        xpath_payloads = [
            "' or '1'='1",
            "'] | //user[@name='admin' and @password='admin'] | //node()['",
            "x' or //user[@name='admin']",
            "') or ('1'='1",
            "' or count(parent::*[position()=1])=0 or 'a'='a",
        ]
        
        for payload in xpath_payloads:
            secret_data = {"secret": payload}
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json')
            
            assert response.status_code == 201
            
            data = json.loads(response.data)
            link_id = data['link_id']
            
            retrieve_response = client.get(f'/api/share/secret/{link_id}')
            retrieved_data = json.loads(retrieve_response.data)
            assert retrieved_data['secret'] == payload
    
    def test_template_injection_attempts(self, client):
        """Test template injection attempts."""
        template_payloads = [
            "{{7*7}}",
            "${7*7}",
            "#{7*7}",
            "<%= 7*7 %>",
            "{{config.items()}}",
            "{{''.__class__.__mro__[2].__subclasses__()}}",
            "{%for item in ().__class__.__base__.__subclasses__()%}",
            "{{request.environ}}",
        ]
        
        for payload in template_payloads:
            secret_data = {"secret": payload}
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json')
            
            assert response.status_code == 201
            
            data = json.loads(response.data)
            link_id = data['link_id']
            
            retrieve_response = client.get(f'/api/share/secret/{link_id}')
            retrieved_data = json.loads(retrieve_response.data)
            
            # Should return literal template code, not executed
            assert retrieved_data['secret'] == payload
            assert "49" not in retrieved_data['secret']  # 7*7 should not be executed


class TestAdvancedDoSAttacks:
    """Test advanced DoS attack vectors."""
    
    def test_algorithmic_complexity_dos(self, client):
        """Test algorithmic complexity DoS attacks."""
        # Test with deeply nested JSON (should be rejected before processing)
        nested_json = '{"secret": '
        for _ in range(100):
            nested_json += '{"nested": '
        nested_json += '"value"'
        for _ in range(100):
            nested_json += '}'
        nested_json += '}'
        
        response = client.post('/api/share',
                              data=nested_json,
                              content_type='application/json')
        
        # Should handle or reject gracefully
        assert response.status_code in [400, 413, 500]
    
    def test_compression_bomb_simulation(self, client):
        """Test compression bomb-like attacks with repetitive data."""
        # Create highly repetitive content that might cause issues if compressed
        bomb_content = "AAAAAAAAAA" * 9000  # ~90KB of repeated data (just under limit)
        
        secret_data = {"secret": bomb_content}
        response = client.post('/api/share',
                              data=json.dumps(secret_data),
                              content_type='application/json')
        
        # Should be accepted as it's just under the limit
        assert response.status_code == 201
    
    def test_resource_exhaustion_through_encryption(self, app_context):
        """Test resource exhaustion through encryption operations."""
        # Test multiple encryption operations rapidly
        start_time = time.time()
        
        for i in range(20):
            secret = f"resource_test_{i}"
            encrypted = encrypt_secret(secret)
            decrypted = decrypt_secret(encrypted)
            assert decrypted == secret
        
        end_time = time.time()
        
        # Should complete within reasonable time
        assert (end_time - start_time) < 5.0, "Encryption operations should not be too slow"
    
    def test_memory_leak_simulation(self, client, app_context):
        """Test for potential memory leaks in request processing."""
        # Store and immediately retrieve multiple secrets
        for i in range(10):
            secret_data = {"secret": f"memory_test_{i}"}
            
            # Store
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json')
            assert response.status_code == 201
            
            data = json.loads(response.data)
            link_id = data['link_id']
            
            # Retrieve immediately
            retrieve_response = client.get(f'/api/share/secret/{link_id}')
            assert retrieve_response.status_code == 200
            
            # Verify memory usage isn't growing excessively
            # (This is a basic test - in production you'd use memory profiling tools)


class TestAdvancedPrivacyAttacks:
    """Test advanced privacy and information disclosure attacks."""
    
    def test_metadata_extraction_attempts(self, client, app_context):
        """Test attempts to extract metadata about secrets."""
        # Store a secret
        secret_data = {"secret": "metadata_test"}
        response = client.post('/api/share',
                              data=json.dumps(secret_data),
                              content_type='application/json')
        
        data = json.loads(response.data)
        link_id = data['link_id']
        
        # Try various metadata extraction attempts - some may return 404, some 405
        metadata_attempts = [
            f"/api/share/secret/{link_id}/metadata",
            f"/api/share/secret/{link_id}/info",
            f"/api/share/secret/{link_id}/stats",
        ]
        
        for attempt in metadata_attempts:
            response = client.get(attempt)
            # Should return 404 (no such endpoint) not metadata
            assert response.status_code == 404
        
        # Query parameter attempts should not expose metadata
        query_attempts = [
            f"/api/share/secret/{link_id}?metadata=true",
            f"/api/share/secret/{link_id}?info=true",
        ]
        
        for attempt in query_attempts:
            response = client.get(attempt)
            # Should retrieve normally (query params ignored) or return 404 if consumed
            assert response.status_code in [200, 404]
        
        # Cleanup - retrieve the secret if it still exists
        try:
            client.get(f'/api/share/secret/{link_id}')
        except:
            pass
    
    def test_secret_content_inference_attacks(self, client, app_context):
        """Test attempts to infer secret content without retrieving."""
        # Store secrets with different characteristics
        secrets = [
            "short",
            "medium_length_secret_content",
            "very_long_secret_content" * 10,
        ]
        
        link_ids = []
        for secret in secrets:
            secret_data = {"secret": secret}
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json')
            
            data = json.loads(response.data)
            link_ids.append(data['link_id'])
        
        # Try to infer content through HEAD requests
        for link_id in link_ids:
            response = client.head(f'/api/share/secret/{link_id}')
            assert response.status_code == 200
            
            # Response should not leak content-length or other metadata
            assert 'Content-Length' not in response.headers or response.headers['Content-Length'] == '0'
            assert response.data == b''
        
        # Cleanup
        for link_id in link_ids:
            client.get(f'/api/share/secret/{link_id}')
    
    def test_timing_based_content_inference(self, client, app_context):
        """Test timing-based content inference attacks."""
        # Store secrets of very different sizes
        small_secret = "a"
        large_secret = "a" * 50000  # 50KB
        
        # Store small secret
        secret_data = {"secret": small_secret}
        response = client.post('/api/share',
                              data=json.dumps(secret_data),
                              content_type='application/json')
        data = json.loads(response.data)
        small_link_id = data['link_id']
        
        # Store large secret
        secret_data = {"secret": large_secret}
        response = client.post('/api/share',
                              data=json.dumps(secret_data),
                              content_type='application/json')
        data = json.loads(response.data)
        large_link_id = data['link_id']
        
        # Time retrieval of both
        start_time = time.time()
        response = client.get(f'/api/share/secret/{small_link_id}')
        small_time = time.time() - start_time
        
        start_time = time.time()
        response = client.get(f'/api/share/secret/{large_link_id}')
        large_time = time.time() - start_time
        
        # Time difference should not be too dramatic (reveals size info)
        time_ratio = large_time / small_time if small_time > 0 else 1
        assert time_ratio < 5, f"Retrieval time should not vary dramatically with size: {time_ratio}x"


class TestAdvancedMisconfigurationAttacks:
    """Test attacks that exploit common misconfigurations."""
    
    def test_default_credentials_attempts(self, client):
        """Test default credentials and common passwords."""
        default_creds = [
            "admin:admin",
            "admin:password", 
            "root:root",
            "admin:123456",
            "test:test",
        ]
        
        # Since this app doesn't have auth, test storing these as secrets
        for cred in default_creds:
            secret_data = {"secret": cred}
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json')
            
            assert response.status_code == 201
            
            data = json.loads(response.data)
            link_id = data['link_id']
            
            # Should store and retrieve exactly
            retrieve_response = client.get(f'/api/share/secret/{link_id}')
            retrieved_data = json.loads(retrieve_response.data)
            assert retrieved_data['secret'] == cred
    
    def test_backup_file_access_attempts(self, client):
        """Test attempts to access backup files or hidden resources."""
        backup_attempts = [
            "/api/share.bak",
            "/api/share~",
            "/api/.share",
            "/api/share.old",
            "/api/share.backup",
            "/.env",
            "/.env.backup",
            "/config.py.bak",
            "/app/.git/config",
        ]
        
        for attempt in backup_attempts:
            response = client.get(attempt)
            # Should return 404, not expose backup files
            assert response.status_code == 404
    
    def test_http_verb_tampering(self, client):
        """Test HTTP verb tampering attacks."""
        secret_data = {"secret": "verb_tamper_test"}
        
        # Test method override headers
        override_headers = [
            {'X-HTTP-Method-Override': 'DELETE'},
            {'X-HTTP-Method': 'PUT'},
            {'X-Method-Override': 'PATCH'},
        ]
        
        for headers in override_headers:
            response = client.post('/api/share',
                                  data=json.dumps(secret_data),
                                  content_type='application/json',
                                  headers=headers)
            
            # Should process as POST, ignore override headers
            assert response.status_code == 201
    
    def test_cors_bypass_attempts(self, client):
        """Test CORS bypass attempts."""
        # Test that the application handles various origin headers
        response = client.get('/health', headers={'Origin': 'http://safe.com'})
        assert response.status_code == 200
        
        # Test that responses don't leak sensitive data
        response_text = response.get_data(as_text=True)
        data = json.loads(response_text)
        assert 'status' in data
        assert data['status'] == 'healthy'